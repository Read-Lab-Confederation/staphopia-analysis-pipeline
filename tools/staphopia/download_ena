#! /usr/bin/env python
""" Download ENA experiments. """
if __name__ == '__main__':
    import os
    import time
    import argparse as ap
    from staphopia.tasks import ena

    parser = ap.ArgumentParser(
        prog='download_ena',
        conflict_handler='resolve',
        description=(''))
    group1 = parser.add_argument_group('Options', '')
    group1.add_argument('output', metavar="OUTPUT_DIR", type=str,
                        help=('Directory to output downloads to.'))
    group1.add_argument('manage', metavar="DJANGO_MANAGE", type=str,
                        help=('Location of Staphopia.com manage.py.'))
    group1.add_argument('--accessions', dest='accessions',
                        help=('Filter results based on accessions specific to '
                              'a column.')),
    group1.add_argument('--column', dest='column',
                        help='Filter results based on specific column.'),
    group1.add_argument('--experiment', metavar="STRING", type=str,
                        help=('Download single experiment.'))
    group1.add_argument('--study', metavar="STRING", type=str,
                        help=('Download single study.'))
    group1.add_argument('--output', metavar="STRING", type=str, default='./',
                        help=('Directory to output downloads to.'))
    group1.add_argument('--limit', metavar="INT", type=int, default=100000,
                        help='Limit the number of experiments to submit.')
    group1.add_argument('--technology', metavar="STRING", type=str,
                        help=('Filter results by a certain technology. '
                              '(ILLUMINA, LS454, PACBIO_SMRT, ION_TORRENT, '
                              'ABI_SOLID)'), default=None)
    group1.add_argument('--coverage', metavar="INT", type=int, default=0,
                        help='Filter results based on coverage.')
    group1.add_argument('--min_read_length', metavar="INT", type=int,
                        help='Filter results by minimum read length.',
                        default=0)
    group1.add_argument('--max_read_length', metavar="INT", type=int,
                        help='Filter results by maximum read length.',
                        default=0)

    group3 = parser.add_argument_group('Optional', '')
    group3.add_argument('-h', '--help', action='help',
                        help='Show this help message and exit')

    args = parser.parse_args()
    ena_json = ena.get_unprocessed_ena(args)
    n = 1
    outdir = '{0}'.format(args.output)
    for experiment_accession in ena_json:
        print('Working on {0} ({1} of {2})...'.format(
            experiment_accession,
            n,
            len(ena_json)
        ))
        n += 1

        # FASTQ file names
        exp_fastq = '{0}/{1}.fastq.gz'.format(outdir, experiment_accession)
        runs = {'r1': [], 'r2': [], 'is_paired': False}

        for run_accession in ena_json[experiment_accession]:
            print('\tWorking on {0}...'.format(run_accession))
            run = ena_json[experiment_accession][run_accession]
            runs['is_paired'] = True if run['is_paired'] else False
            for i in xrange(len(run['fastq_aspera'])):
                if run['fastq_md5'][i]:
                    fastq_md5 = run['fastq_md5'][i]
                    dl_md5 = None
                    fasp = run['fastq_aspera'][i]
                    while (fastq_md5 != dl_md5):
                        fastq = '{0}/{1}'.format(
                            outdir, format(os.path.basename(fasp))
                        )
                        print('\t\tDownloading {0}...'.format(fastq))
                        dl_md5 = ena.download_fastq(fasp, outdir, fastq)
                        if dl_md5 == fastq_md5:
                            print('\t\tMD5s match, {0}\t{1}'.format(
                                fastq_md5, dl_md5
                            ))
                            if fastq.endswith("_1.fastq.gz"):
                                runs['r1'].append(fastq)
                            elif fastq.endswith("_2.fastq.gz"):
                                runs['r2'].append(fastq)
                            else:
                                runs['r1'].append(fastq)
                        else:
                            print(('\t\tMD5s do not match... sleeping for 60s'
                                   ', {0}\t{1}').format(
                                fastq_md5, dl_md5
                            ))
                            time.sleep(60)

        # Merge Runs to Exp
        if runs['is_paired'] and len(runs['r1']) and len(runs['r2']):
            # Not all runs labled as paired are actually paired...
            print("\tMerging paired end runs to experiment...")
            r1 = '{0}/{1}_R1.fastq.gz'.format(outdir, experiment_accession)
            r2 = '{0}/{1}_R2.fastq.gz'.format(outdir, experiment_accession)
            ena.merge_runs(runs['r1'], r1)
            ena.merge_runs(runs['r2'], r2)
        else:
            print("\tMerging single end runs to experiment...")
            fastq = '{0}/{1}.fastq.gz'.format(outdir, experiment_accession)
            ena.merge_runs(runs['r1'], fastq)
