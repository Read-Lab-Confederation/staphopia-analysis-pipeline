#! /usr/bin/env python
""" Download ENA experiments. """
if __name__ == '__main__':
    import os
    import sys
    import argparse as ap
    from staphopia import ena
    from staphopia.config import BIN

    parser = ap.ArgumentParser(
        prog='download_ena',
        conflict_handler='resolve',
        description=(''))
    group1 = parser.add_argument_group('Options', '')
    group1.add_argument('--output', metavar="STRING", type=str, default='./',
                        help=('Directory to output downloads to.'))
    group1.add_argument('--s3', metavar="STRING", type=str, default='./s3',
                        help=('Directory to move downloads to.'))
    group1.add_argument('--limit', metavar="INT", type=int, default=100000,
                        help='Limit the number of experiments to submit.')
    group1.add_argument('--technology', metavar="STRING", type=str,
                        help=('Filter results by a certain technology. '
                              '(ILLUMINA, LS454, PACBIO_SMRT, ION_TORRENT, '
                              'ABI_SOLID)'), default=None)
    group1.add_argument('--coverage', metavar="INT", type=int, default=0,
                        help='Filter results based on coverage.')
    group1.add_argument('--min_read_length', metavar="INT", type=int,
                        help='Filter results by minimum read length.',
                        default=0)
    group1.add_argument('--max_read_length', metavar="INT", type=int,
                        help='Filter results by maximum read length.',
                        default=0)
    group1.add_argument('-p', '--processors', metavar="INT", type=int,
                        help='Number of processors to use. (Default 1)',
                        default=1)
    group1.add_argument('--production', action='store_true', default=False,
                        help='Use production server settings', )
    group1.add_argument('--debug', action='store_true', default=False,
                        help='Do not save results to database')

    group3 = parser.add_argument_group('Optional', '')
    group3.add_argument('-h', '--help', action='help',
                        help='Show this help message and exit')

    if len(sys.argv) == 1:
        parser.print_usage()
        sys.exit(1)

    args = parser.parse_args()

    config = {
        'n_cpu': str(args.processors),
        'settings': 'staphopia.settings.{0}'.format(
            'prod' if args.production else 'dev'
        ),
        'ascp': BIN['ascp'],
        'ssh_key': BIN['aspera_key'],
        'fastq_interleave': BIN['fastq_interleave'],
        'manage': BIN['manage'],
    }

    ena_obj = ena.ENA(config)
    ena_obj.get_unprocessed_ena(args)
    total = len(ena_obj.enainfo)
    n = 1
    outdir = '{0}/'.format(args.output)
    s3 = '{0}/'.format(args.s3)
    for experiment_accession in ena_obj.enainfo:
        print 'Working on {0} ({1} of {2})...'.format(
            experiment_accession,
            n,
            total
        )
        n += 1
        merge_runs = []

        # FASTQ file names
        ebs_fastq = '{0}{1}.fastq.gz'.format(outdir, experiment_accession)
        s3_fastq = '{0}{1}.fastq.gz'.format(s3, experiment_accession)

        if os.path.exists(s3_fastq):
            print '\t{0} exists, skipping...'.format(s3_fastq)
            continue

        for run_accession in ena_obj.enainfo[experiment_accession]:
            print '\tWorking on {0}...'.format(run_accession)
            run = ena_obj.enainfo[experiment_accession][run_accession]
            runs = []
            for fasp in run['fastq_aspera'].split(';'):
                if fasp:
                    fastq = '{0}{1}'.format(
                        outdir, format(os.path.basename(fasp))
                    )
                    print '\t\tDownloading {0}...'.format(fastq)
                    runs.append(fastq)
                    ena_obj.download_fastq(fasp, outdir, fastq)

            if run['is_paired']:
                print '\t\tInterleave FASTQ {0}, {1}'.format(runs[0], runs[1])
                interleaved = '{0}{1}.fastq.gz'.format(outdir, run_accession)
                ena_obj.interleave_fastq(runs, interleaved)
                merge_runs.append(interleaved)
            else:
                for r in runs:
                    merge_runs.append(r)
        print '\tMerging runs into {0}{1}.fastq.gz'.format(
            outdir, experiment_accession
        )
        ena_obj.merge_runs(merge_runs, '{0}{1}.fastq.gz'.format(
            outdir, experiment_accession
        ))
        print '\tMoving to S3 bucket...'

        ebs_md5 = ena_obj.get_md5sum(ebs_fastq)
        s3_md5 = None
        ebs_fastq
        while (ebs_md5 != s3_md5):
            ena_obj.copy_file(ebs_fastq, s3_fastq)
            s3_md5 = ena_obj.get_md5sum(s3_fastq)
            print '\t\tMD5sum --- EBS={0}\tS3={1}'.format(ebs_md5, s3_md5)
        print "\tSuccesfully copied to S3"
        print "\tRemove from EBS volume"
        ena_obj.remove_file(ebs_fastq)
